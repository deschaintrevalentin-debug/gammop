<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAMMOP - Administration</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --text-primary: #000000;
            --text-secondary: #666666;
            --text-accent: #2d5016;
            --border-color: #e0e0e0;
            --section-bg: #f8fdf9;
            --section-border: #c8e6c9;
            --card-bg: #ffffff;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --text-primary: #f5f5f5;
            --text-secondary: #d1d5db;
            --text-accent: #a7f3d0;
            --border-color: #404040;
            --section-bg: #2a2a2a;
            --section-border: #404040;
            --card-bg: #2a2a2a;
        }

        body.dark-mode h3 { color: #7bed9f !important; }
        body.dark-mode [style*="color:#2d5016"], body.dark-mode [style*="color: #2d5016"] { color: #7bed9f !important; }
        body.dark-mode [style*="color:#4a7c28"], body.dark-mode [style*="color: #4a7c28"] { color: #7bed9f !important; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
        }

        body.dark-mode { background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%); }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        header h1 { font-size: 2em; font-weight: 900; letter-spacing: 4px; text-transform: uppercase; }
        header p { font-size: 1em; opacity: 0.9; margin-top: 5px; }

        .header-btns {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
        }

        .tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            overflow-x: auto;
            padding: 0 10px;
        }

        .tab-btn {
            padding: 15px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-btn:hover { color: var(--text-accent); background: rgba(74, 124, 40, 0.1); }
        .tab-btn.active { color: #4a7c28; border-bottom-color: #4a7c28; }

        .content { display: none; padding: 25px; }
        .content.active { display: block; }

        .section {
            background: var(--section-bg);
            border: 2px solid var(--section-border);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .section h3 { color: #2d5016; margin-bottom: 15px; font-size: 1.2em; }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 0.95em;
        }

        .btn:hover { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
        .btn-primary { background: #4a7c28; color: white; }
        .btn-primary:hover { background: #3d6b1f; }
        .btn-secondary { background: #6c757d; color: white; margin-right: 10px; }
        .btn-secondary:hover { background: #5a6268; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; }

        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; font-weight: 600; margin-bottom: 8px; color: var(--text-accent); }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #4a7c28;
        }

        .form-group textarea { min-height: 120px; resize: vertical; }

        .msg {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            font-weight: 600;
        }

        .msg-success { background: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .msg-error { background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }

        .preview-box {
            background: var(--section-bg);
            border: 2px solid #4a7c28;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            display: none;
        }

        /* Login screen */
        #loginScreen {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(100vh - 40px);
        }

        .login-box {
            background: var(--bg-primary);
            border-radius: 20px;
            padding: 40px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .login-box h1 { color: #e74c3c; font-size: 2em; margin-bottom: 5px; }
        .login-box p { color: var(--text-secondary); margin-bottom: 25px; }

        /* Season cards */
        .season-card {
            background: var(--section-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--section-border);
        }

        .season-card h4 { color: #2d5016; margin-bottom: 5px; }
        .season-card p { color: var(--text-secondary); font-size: 0.9em; }

        .season-actions { display: flex; gap: 8px; flex-shrink: 0; }

        /* Confirm modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: var(--bg-primary);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-content h2 { margin-bottom: 15px; color: var(--text-primary); }
        .modal-content p { margin-bottom: 20px; line-height: 1.6; color: var(--text-secondary); }

        /* Loading */
        .loading { text-align: center; padding: 40px; color: var(--text-secondary); }

        @media (max-width: 768px) {
            header h1 { font-size: 1.5em; }
            .tabs { flex-direction: column; }
            .tab-btn { width: 100%; text-align: left; }
            .season-card { flex-direction: column; gap: 10px; }
            .season-actions { width: 100%; }
            .season-actions .btn { flex: 1; text-align: center; }
        }
    </style>
</head>
<body>

<!-- Detect auth callback SYNCHRONOUSLY before any screen renders -->
<script>
    (function() {
        var h = window.location.hash || '';
        var s = window.location.search || '';
        // Magic Link / OAuth implicit: #access_token   |   OAuth PKCE: ?code=
        if (h.indexOf('access_token') !== -1 || s.indexOf('code=') !== -1) {
            document.documentElement.setAttribute('data-auth-callback', 'true');
        }
    })();
</script>

<!-- ==================== LOADING SCREEN (auth callback) ==================== -->
<div id="loadingScreen" style="display:none">
    <div class="login-box" style="text-align:center">
        <h1>GAMMOP</h1>
        <p id="loadingText" style="margin-top:20px;font-size:1.2em">Connexion en cours...</p>
        <div id="loadingError" class="msg msg-error" style="margin-top:15px"></div>
    </div>
</div>

<!-- ==================== LOGIN SCREEN ==================== -->
<div id="loginScreen" style="display:none">
    <div class="login-box">
        <h1>GAMMOP</h1>
        <p>Administration</p>
        <div id="loginError" class="msg msg-error"></div>
        <div id="loginSuccess" class="msg msg-success"></div>
        <div class="form-group">
            <label>Email</label>
            <input type="email" id="loginEmail" placeholder="admin@example.com">
        </div>
        <button class="btn btn-primary" onclick="handleMagicLink()" style="width:100%;padding:15px;font-size:1.1em">Envoyer un Magic Link</button>
        <hr style="margin:15px 0;border:none;border-top:1px solid var(--border-color)">
        <div class="form-group">
            <label>Mot de passe</label>
            <input type="password" id="loginPassword" onkeypress="if(event.key==='Enter') handleLogin()">
        </div>
        <button class="btn btn-secondary" onclick="handleLogin()" style="width:100%;padding:12px;font-size:1em">Se connecter avec mot de passe</button>
        <hr style="margin:15px 0;border:none;border-top:1px solid var(--border-color)">
        <button onclick="handleGitHubLogin()" style="width:100%;padding:13px;font-size:1em;cursor:pointer;border:none;border-radius:6px;background:#24292e;color:#fff;display:flex;align-items:center;justify-content:center;gap:8px">
            <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
            Se connecter avec GitHub
        </button>
    </div>
</div>

<!-- ==================== ADMIN INTERFACE ==================== -->
<div id="adminInterface" style="display:none">
    <div class="container">
        <header>
            <h1>GAMMOP Admin</h1>
            <p>Gestion des classements</p>
            <div class="header-btns">
                <button class="btn" onclick="toggleDarkMode()" style="background:#2d3748;color:white" title="Mode sombre">&#127769;</button>
                <button class="btn btn-danger" onclick="handleLogout()">Deconnexion</button>
            </div>
        </header>

        <div class="tabs">
            <button class="tab-btn active" onclick="showAdminTab('seasons', this)">Saisons</button>
            <button class="tab-btn" onclick="showAdminTab('add', this)">Ajouter</button>
            <button class="tab-btn" onclick="showAdminTab('pseudos', this)">Pseudos</button>
            <button class="tab-btn" onclick="showAdminTab('backup', this)">Backup</button>
            <button class="tab-btn" onclick="showAdminTab('ptibak', this)">üé≤ Ptibak</button>
        </div>

        <!-- TAB: SAISONS -->
        <div id="seasons" class="content active">
            <div class="section">
                <h3>Liste des Saisons</h3>
                <div id="supabaseStatus" style="margin-bottom:12px;padding:10px 14px;border-radius:8px;background:var(--section-bg);border:1px solid var(--border-color);font-size:13px;color:var(--text-secondary)">
                    Supabase: chargement...
                </div>
                <div style="margin-bottom:8px;font-size:11px;color:var(--text-secondary);font-family:monospace;opacity:0.7">
                    DB: <span id="supabaseUrlDisplay"></span>
                </div>
                <div id="seasonsList"><p class="loading">Chargement...</p></div>
            </div>
        </div>

        <!-- TAB: AJOUTER -->
        <div id="add" class="content">
            <div class="section">
                <h3 id="addTitle">Ajouter une Saison</h3>
                <div id="successMsg" class="msg msg-success"></div>
                <div id="errorMsg" class="msg msg-error"></div>

                <div class="form-group">
                    <label style="display:flex;align-items:center;gap:10px;cursor:pointer;margin:0">
                        <input type="checkbox" id="isSpecialSeason" onchange="toggleSpecialSeasonFields()" style="margin:0;width:auto;flex-shrink:0">
                        <span style="font-weight:bold">&#127824; Saison Speciale</span>
                    </label>
                </div>

                <div class="form-group">
                    <label>Jeu</label>
                    <select id="seasonGame">
                        <option value="Majority">Majority</option>
                        <option value="Kulture">Kulture</option>
                        <option value="Hungerity">Hungerity</option>
                        <option value="Pronostik">Pronostik</option>
                        <option value="GuessWer">GuessWer</option>
                        <option value="GuessWat">GuessWat</option>
                        <option value="GuessWo">GuessWo</option>
                        <option value="KrossWord">KrossWord</option>
                        <option value="Ptibak">Ptibak</option>
                        <option value="Justepoi">Justepoi</option>
                        <option value="Disgame">Disgame</option>
                        <option value="Colanta">Colanta</option>
                    </select>
                </div>

                <div class="form-group" id="normalSeasonNumberGroup">
                    <label>Numero de Saison</label>
                    <input type="number" id="seasonNumber" min="1" placeholder="Ex: 1">
                </div>

                <div class="form-group" id="specialSeasonNumberGroup" style="display:none">
                    <label>Numero de Saison Speciale</label>
                    <input type="number" id="specialSeasonNumber" min="1" placeholder="Ex: 1 (pour #1)">
                </div>

                <div id="specialityGroup" style="display:none">
                    <div class="form-group">
                        <label style="font-weight:bold">Specificite</label>
                        <div style="margin-top:10px">
                            <label style="display:flex;align-items:center;gap:6px;margin-bottom:10px;cursor:pointer">
                                <input type="radio" name="specialityType" value="organizer" onchange="toggleSpecialityFields()" style="margin:0;width:auto;flex-shrink:0">
                                <span>Organise par</span>
                            </label>
                            <div id="organizerField" style="display:none;margin-left:30px;margin-bottom:15px">
                                <input type="text" id="organizerName" placeholder="Pseudo de l'organisateur" style="width:100%;padding:10px;border:1px solid #ddd;border-radius:5px">
                            </div>
                            <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="radio" name="specialityType" value="other" onchange="toggleSpecialityFields()" style="margin:0;width:auto;flex-shrink:0">
                                <span>Autre</span>
                            </label>
                            <div id="otherSpecialityField" style="display:none;margin-left:30px;margin-top:10px">
                                <textarea id="otherSpeciality" placeholder="Decrire la specificite de cette saison..." style="width:100%;padding:10px;border:1px solid #ddd;border-radius:5px;min-height:80px"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Date</label>
                    <input type="date" id="seasonDate">
                </div>

                <div class="form-group">
                    <label>Lien Google Docs (optionnel)</label>
                    <input type="url" id="seasonGdocLink" placeholder="https://docs.google.com/...">
                </div>

                <div class="form-group">
                    <label>Classement (un pseudo par ligne)</label>
                    <textarea id="seasonRanking" placeholder="Pseudo1&#10;Pseudo2&#10;Pseudo3&#10;..."></textarea>
                </div>

                <div style="display:flex;gap:10px">
                    <button class="btn btn-primary" id="addBtn" onclick="addSeason()">Ajouter la Saison</button>
                    <button class="btn btn-secondary" id="cancelEditBtn" onclick="cancelEdit()" style="display:none">Annuler</button>
                </div>
            </div>
        </div>

        <!-- TAB: PSEUDOS -->
        <div id="pseudos" class="content">
            <div class="section">
                <h3>&#9888;&#65039; Pseudos Similaires Detectes</h3>
                <p style="color:var(--text-secondary);margin-bottom:20px">Ces pseudos semblent etre identiques mais ne sont pas regroupes ensemble.</p>
                <div id="similarPseudos"><p class="loading">Chargement...</p></div>
            </div>

            <div class="section">
                <h3>&#128247; Photos de Profil Discord</h3>
                <div id="discordSuccess" class="msg msg-success"></div>
                <div id="discordError" class="msg msg-error"></div>
                <p style="color:var(--text-secondary);margin-bottom:20px">Liez les pseudos du site avec les IDs utilisateurs Discord pour afficher les photos de profil.</p>
                <div class="form-group">
                    <label>Pseudo du site</label>
                    <select id="discordPseudo"><option value="">-- Selectionner un pseudo --</option></select>
                </div>
                <div class="form-group">
                    <label>ID utilisateur Discord</label>
                    <input type="text" id="discordUserId" placeholder="Ex: 123456789012345678">
                    <small style="color:var(--text-secondary);display:block;margin-top:5px">Pour obtenir l'ID : Activez le mode developpeur dans Discord, clic droit sur l'utilisateur > Copier l'identifiant</small>
                </div>
                <button class="btn btn-primary" onclick="linkDiscordProfile()">Lier le profil</button>
                <div id="discordProfilesList" style="margin-top:20px"></div>
            </div>

            <div class="section">
                <h3>&#8617;&#65039; Annuler un Regroupement</h3>
                <div id="undoMergeSuccess" class="msg msg-success"></div>
                <div id="undoMergeError" class="msg msg-error"></div>
                <p style="color:var(--text-secondary);margin-bottom:20px">Annulez un regroupement de pseudos effectue par erreur.</p>
                <div id="mergeHistoryList"></div>
            </div>

            <div class="section">
                <h3>Renommer un Pseudo</h3>
                <div id="pseudoSuccess" class="msg msg-success"></div>
                <div id="pseudoError" class="msg msg-error"></div>
                <div class="form-group">
                    <label>Ancien Pseudo</label>
                    <select id="oldPseudo" onchange="previewRename()"><option value="">-- Selectionner --</option></select>
                </div>
                <div class="form-group">
                    <label>Nouveau Pseudo</label>
                    <input type="text" id="newPseudo" oninput="previewRename()" placeholder="Nouveau nom">
                </div>
                <div id="preview" class="preview-box"></div>
                <div style="display:flex;gap:10px;margin-top:20px">
                    <button class="btn btn-primary" onclick="renamePseudo()">Renommer</button>
                    <button class="btn btn-secondary" onclick="cancelRename()">Annuler</button>
                </div>
            </div>
        </div>

        <!-- TAB: BACKUP -->
        <div id="backup" class="content">
            <div class="section">
                <h3>Export des Donnees</h3>
                <div id="backupSuccess" class="msg msg-success"></div>
                <div id="backupError" class="msg msg-error"></div>
                <p style="color:var(--text-secondary);margin-bottom:20px">Exportez vos donnees pour les sauvegarder ou les transferer.</p>
                <div style="display:flex;gap:10px;flex-wrap:wrap">
                    <button class="btn btn-primary" onclick="exportToClipboard()">Copier dans le Presse-papier</button>
                    <button class="btn btn-primary" onclick="downloadBackup()">Telecharger Fichier JSON</button>
                </div>
            </div>
            <div class="section">
                <h3>Import des Donnees</h3>
                <div class="form-group">
                    <label>Coller les donnees JSON</label>
                    <textarea id="importData" placeholder='[{"game":"Majority","name":"Majority Saison 1","date":"2024-01-01","players":["Joueur1","Joueur2"]}]'></textarea>
                </div>
                <button class="btn btn-primary" onclick="importFromText()">Importer depuis le texte</button>
                <div style="margin:20px 0;text-align:center;color:var(--text-secondary)">OU</div>
                <div class="form-group">
                    <label>Importer depuis un fichier</label>
                    <input type="file" accept=".json" onchange="importFromFile(event)" style="padding:10px;border:2px dashed #4a7c28;border-radius:8px;background:var(--section-bg)">
                </div>
                <div id="importLog" style="margin-top:15px;padding:12px;background:#1a1a2e;color:#0f0;font-family:monospace;font-size:12px;border-radius:8px;display:none;max-height:200px;overflow:auto;white-space:pre-wrap"></div>
            </div>
            <div class="section">
                <h3>Test Edge Function</h3>
                <p style="color:var(--text-secondary);margin-bottom:10px">Insere 1 saison de test via la Edge Function (service_role, bypass RLS).</p>
                <button class="btn btn-secondary" onclick="testInsertOneSeason()">Test insert 1 saison</button>
                <div id="testResult" style="margin-top:10px"></div>
            </div>
        </div>

        <!-- TAB: PTIBAK -->
        <div id="ptibak" class="content">
            <div class="section">
                <h3>üé≤ Ptibak - Assistant de Poule</h3>
                <p style="color:var(--text-secondary);margin-bottom:20px">Outil pour g√©rer les poules du Ptibak sur Discord.</p>

                <!-- SETUP PHASE -->
                <div id="ptibakSetup">
                    <div class="form-group">
                        <label>Nombre de joueurs dans la poule (2-30)</label>
                        <input type="number" id="ptibakPlayerCount" min="2" max="30" value="6" style="width:100px;padding:8px;border:2px solid var(--border-color);border-radius:8px;font-size:1em;background:var(--bg-primary);color:var(--text-primary)">
                    </div>
                    <div class="form-group">
                        <label>Noms des joueurs (un par ligne)</label>
                        <textarea id="ptibakPlayerNames" placeholder="Joueur1&#10;Joueur2&#10;Joueur3&#10;..." style="min-height:150px"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Points n√©cessaires pour se qualifier</label>
                        <input type="number" id="ptibakQualifPoints" min="1" value="7" style="width:100px;padding:8px;border:2px solid var(--border-color);border-radius:8px;font-size:1em;background:var(--bg-primary);color:var(--text-primary)">
                    </div>
                    <div class="form-group">
                        <label>Nombre de places qualificatives</label>
                        <input type="number" id="ptibakQualifSlots" min="1" value="3" style="width:100px;padding:8px;border:2px solid var(--border-color);border-radius:8px;font-size:1em;background:var(--bg-primary);color:var(--text-primary)">
                    </div>
                    <button class="btn btn-primary" onclick="ptibakStart()">D√©marrer la Poule</button>
                </div>

                <!-- GAME PHASE (hidden initially) -->
                <div id="ptibakGame" style="display:none">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
                        <h4 style="color:var(--text-accent)">Tour en cours</h4>
                        <button class="btn btn-danger" onclick="ptibakReset()" style="font-size:0.85em;padding:6px 14px">R√©initialiser</button>
                    </div>

                    <div id="ptibakInfo" style="background:var(--section-bg);padding:12px;border-radius:8px;border:1px solid var(--section-border);margin-bottom:15px;font-size:0.9em;color:var(--text-secondary)"></div>

                    <!-- Player buttons grid -->
                    <div id="ptibakPlayers" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;margin-bottom:20px"></div>

                    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:20px">
                        <button class="btn btn-primary" onclick="ptibakValidateRound()">‚úÖ Valider le tour</button>
                        <button class="btn btn-secondary" onclick="ptibakUndoRound()" id="ptibakUndoBtn" style="display:none">‚Ü©Ô∏è Annuler dernier tour</button>
                    </div>

                    <!-- Discord message output -->
                    <div id="ptibakOutput" style="display:none">
                        <h4 style="color:var(--text-accent);margin-bottom:10px">Message Discord</h4>
                        <div id="ptibakMessage" style="background:#36393f;color:#dcddde;padding:15px;border-radius:8px;font-family:'Segoe UI',sans-serif;font-size:0.95em;white-space:pre-wrap;line-height:1.6;cursor:pointer;border:2px solid #4a7c28" onclick="ptibakCopyMessage()" title="Cliquer pour copier"></div>
                        <p style="color:var(--text-secondary);font-size:0.85em;margin-top:8px">Cliquez sur le message pour le copier</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- CONFIRM MODAL -->
<div id="confirmModal" class="modal" onclick="if(event.target===this) closeConfirm(false)">
    <div class="modal-content">
        <h2>Confirmation</h2>
        <p id="confirmMsg"></p>
        <div style="display:flex;gap:10px">
            <button class="btn btn-danger" onclick="closeConfirm(true)" style="flex:1">Confirmer</button>
            <button class="btn btn-secondary" onclick="closeConfirm(false)" style="flex:1">Annuler</button>
        </div>
    </div>
</div>

<script>
// ==================== GLOBAL ERROR HANDLER ====================
window.addEventListener('unhandledrejection', function(event) {
    console.error('[UNHANDLED REJECTION]', event.reason);
    var el = document.getElementById('testResult');
    if (el) el.innerHTML = '<span style="color:red">ERREUR NON CAPTUREE: ' + (event.reason && event.reason.message ? event.reason.message : String(event.reason)) + '</span>';
    var log = document.getElementById('importLog');
    if (log) { log.style.display = 'block'; log.textContent += '[UNHANDLED] ' + (event.reason && event.reason.message ? event.reason.message : String(event.reason)) + '\n'; }
});

// ==================== SUPABASE CONFIG ====================
const SUPABASE_URL = 'https://kxpixfddhqltyxnmeuzl.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4cGl4ZmRkaHFsdHl4bm1ldXpsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4ODk5NDIsImV4cCI6MjA4NTQ2NTk0Mn0.9Ld6co_CfTt3JBzjySpkDH_PVIYXf9h8QBqUPlmpPxE';
if (!window.supabase) {
    document.body.innerHTML = '<div style="padding:40px;text-align:center;color:#721c24;background:#f8d7da;border-radius:8px;margin:40px">'
        + '<h2>Erreur critique</h2><p>Supabase SDK non charg√©. V√©rifiez votre connexion internet.</p></div>';
    throw new Error('Supabase SDK not loaded');
}
const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ==================== STATE ====================
let seasons = [];
let discordProfiles = {};
let discordAvatars = {};
let mergeHistory = [];
let currentUser = null;
let currentSession = null; // Stocke la session auth ‚Äî mis a jour par onAuthStateChange
let editingSeasonId = null;
let confirmCb = null;
let ignoredPairs = new Set();
let currentSimilarGroups = [];

// ==================== AUTH ====================

let authResolved = false; // tracks whether we have shown a screen

// --- Screen helpers: only ONE screen visible at a time ---
function hideAllScreens() {
    document.getElementById('loadingScreen').style.display = 'none';
    document.getElementById('loginScreen').style.display = 'none';
    document.getElementById('adminInterface').style.display = 'none';
}

function showLoadingScreen() {
    hideAllScreens();
    document.getElementById('loadingScreen').style.display = '';
}

function showAdmin(user) {
    hideAllScreens();
    authResolved = true;
    currentUser = user;
    document.getElementById('adminInterface').style.display = '';
    // Show Supabase URL (sans cle)
    var urlDisplay = document.getElementById('supabaseUrlDisplay');
    if (urlDisplay) urlDisplay.textContent = SUPABASE_URL;
    console.log('[AUTH] session found ‚Äî showing admin for', user.email || user.id);
}

function showLogin() {
    hideAllScreens();
    authResolved = true;
    currentUser = null;
    document.getElementById('loginScreen').style.display = '';
    console.log('[AUTH] no session ‚Äî showing login');
}

// --- Message helpers ---
function showLoginError(msg) {
    const errEl = document.getElementById('loginError');
    errEl.textContent = msg;
    errEl.style.display = 'block';
    const successEl = document.getElementById('loginSuccess');
    if (successEl) successEl.style.display = 'none';
}

function showLoginSuccess(msg) {
    const successEl = document.getElementById('loginSuccess');
    successEl.textContent = msg;
    successEl.style.display = 'block';
    document.getElementById('loginError').style.display = 'none';
}

function showLoadingError(msg) {
    const errEl = document.getElementById('loadingError');
    errEl.textContent = msg;
    errEl.style.display = 'block';
}

// --- Magic Link / implicit OAuth callback: tokens in hash ---
async function handleHashCallback() {
    const hash = window.location.hash.substring(1);
    if (!hash) return false;

    const params = new URLSearchParams(hash);
    const accessToken = params.get('access_token');
    const refreshToken = params.get('refresh_token');

    if (!accessToken || !refreshToken) return false;

    console.log('[AUTH] hash callback detected ‚Äî consuming tokens');
    showLoadingScreen();

    // Clean URL to remove tokens
    window.history.replaceState(null, '', window.location.pathname);

    const { data, error } = await sb.auth.setSession({
        access_token: accessToken,
        refresh_token: refreshToken
    });

    if (error) {
        console.error('[AUTH] setSession error:', error.message);
        showLoadingError('Erreur d\'authentification : ' + error.message);
        setTimeout(() => showLogin(), 3000);
        return false;
    }

    if (data && data.session) currentSession = data.session; // Stocker
    console.log('[AUTH] setSession OK');
    return true;
}

// --- Session check ---
async function checkSession() {
    try {
        const { data: { session }, error } = await sb.auth.getSession();
        if (error) {
            console.error('[AUTH] getSession error:', error.message);
            showLogin();
            showLoginError('Erreur de session : ' + error.message);
            return;
        }
        if (session) {
            currentSession = session; // Stocker
            showAdmin(session.user);
            await loadAllData();
        } else {
            console.log('[AUTH] getSession returned null');
            currentSession = null;
            showLogin();
        }
    } catch (e) {
        console.error('[AUTH] checkSession exception:', e);
        showLogin();
        showLoginError('Erreur inattendue : ' + e.message);
    }
}

// --- Login with password ---
async function handleLogin() {
    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;
    if (!email || !password) {
        showLoginError('Veuillez entrer votre email et mot de passe');
        return;
    }

    document.getElementById('loginError').style.display = 'none';
    document.getElementById('loginSuccess').style.display = 'none';

    const { data, error } = await sb.auth.signInWithPassword({ email, password });

    if (error) {
        showLoginError(error.message === 'Invalid login credentials'
            ? 'Email ou mot de passe incorrect'
            : error.message);
        return;
    }

    showAdmin(data.user);
    await loadAllData();
}

// --- Send Magic Link email ---
async function handleMagicLink() {
    const email = document.getElementById('loginEmail').value.trim();
    if (!email) {
        showLoginError('Veuillez entrer votre email');
        return;
    }

    document.getElementById('loginError').style.display = 'none';
    document.getElementById('loginSuccess').style.display = 'none';

    const { error } = await sb.auth.signInWithOtp({
        email,
        options: { emailRedirectTo: window.location.origin + window.location.pathname }
    });

    if (error) {
        showLoginError(error.message);
        return;
    }

    showLoginSuccess('Magic link envoy√© ! V√©rifiez votre bo√Æte mail.');
}

// --- GitHub OAuth ---
async function handleGitHubLogin() {
    document.getElementById('loginError').style.display = 'none';
    document.getElementById('loginSuccess').style.display = 'none';

    const { error } = await sb.auth.signInWithOAuth({
        provider: 'github',
        options: { redirectTo: window.location.origin + window.location.pathname }
    });

    if (error) {
        showLoginError(error.message);
    }
}

// --- Logout ---
async function handleLogout() {
    if (!confirm('Se d√©connecter ?')) return;
    await sb.auth.signOut();
    showLogin();
}

// --- Auth state listener: catches OAuth PKCE exchange, token refresh, etc. ---
sb.auth.onAuthStateChange(async (event, session) => {
    console.log('[AUTH] onAuthStateChange:', event, session ? session.user.email || session.user.id : 'null');

    // TOUJOURS stocker la session (ou null si deconnexion)
    currentSession = session;

    if (session && (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'INITIAL_SESSION')) {
        // Only act if we haven't already shown admin (avoid double loadAllData)
        if (currentUser && currentUser.id === session.user.id) return;
        showAdmin(session.user);
        await loadAllData();
    } else if (event === 'SIGNED_OUT') {
        currentSession = null;
        showLogin();
    }
});

// ==================== DATA LOADING (raw fetch ‚Äî contourne le SDK instable) ====================
var REST_BASE = SUPABASE_URL + '/rest/v1';
var REST_HEADERS = { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY };

async function restGet(table, query) {
    var resp = await fetch(REST_BASE + '/' + table + '?' + (query || 'select=*'), {
        headers: Object.assign({ 'Content-Type': 'application/json' }, REST_HEADERS)
    });
    if (!resp.ok) {
        var body = await resp.text();
        throw new Error('REST GET ' + table + ' failed: HTTP ' + resp.status + ' ' + body.substring(0, 200));
    }
    return resp.json();
}

async function restPost(table, row) {
    var resp = await fetch(REST_BASE + '/' + table, {
        method: 'POST',
        headers: Object.assign({ 'Content-Type': 'application/json', 'Prefer': 'return=representation' }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {}),
        body: JSON.stringify(row)
    });
    var data = await resp.json();
    if (!resp.ok) throw new Error('REST POST ' + table + ': ' + (data.message || JSON.stringify(data)));
    return data;
}

async function restPatch(table, id, row) {
    var resp = await fetch(REST_BASE + '/' + table + '?id=eq.' + id, {
        method: 'PATCH',
        headers: Object.assign({ 'Content-Type': 'application/json', 'Prefer': 'return=representation' }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {}),
        body: JSON.stringify(row)
    });
    var data = await resp.json();
    if (!resp.ok) throw new Error('REST PATCH ' + table + ': ' + (data.message || JSON.stringify(data)));
    return data;
}

async function restDelete(table, id) {
    var resp = await fetch(REST_BASE + '/' + table + '?id=eq.' + id, {
        method: 'DELETE',
        headers: Object.assign({ 'Content-Type': 'application/json' }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {})
    });
    if (!resp.ok) {
        var body = await resp.text();
        throw new Error('REST DELETE ' + table + ': HTTP ' + resp.status + ' ' + body.substring(0, 200));
    }
}

async function restDeleteWhere(table, filter) {
    var resp = await fetch(REST_BASE + '/' + table + '?' + filter, {
        method: 'DELETE',
        headers: Object.assign({ 'Content-Type': 'application/json' }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {})
    });
    if (!resp.ok) {
        var body = await resp.text();
        throw new Error('REST DELETE ' + table + ': HTTP ' + resp.status + ' ' + body.substring(0, 200));
    }
}

async function restPatchWhere(table, filter, row) {
    var resp = await fetch(REST_BASE + '/' + table + '?' + filter, {
        method: 'PATCH',
        headers: Object.assign({ 'Content-Type': 'application/json', 'Prefer': 'return=representation' }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {}),
        body: JSON.stringify(row)
    });
    if (!resp.ok) {
        var body = await resp.text();
        throw new Error('REST PATCH ' + table + ': HTTP ' + resp.status + ' ' + body.substring(0, 200));
    }
    return resp.json();
}

async function restUpsert(table, row, onConflict) {
    var resp = await fetch(REST_BASE + '/' + table, {
        method: 'POST',
        headers: Object.assign({
            'Content-Type': 'application/json',
            'Prefer': 'return=representation,resolution=merge-duplicates'
        }, REST_HEADERS,
            currentSession ? { 'Authorization': 'Bearer ' + currentSession.access_token } : {}),
        body: JSON.stringify(row)
    });
    if (!resp.ok) {
        var body = await resp.text();
        throw new Error('REST UPSERT ' + table + ': HTTP ' + resp.status + ' ' + body.substring(0, 200));
    }
    return resp.json();
}

async function loadAllData() {
    try {
        await Promise.all([loadSeasons(), loadDiscordProfiles(), loadMergeHistory()]);
    } catch (e) {
        console.error('loadAllData error:', e);
    }
    renderSeasonsList();
    updatePseudosList();
    updateSimilarPseudos();
    renderDiscordProfilesList();
    renderMergeHistory();
}

async function loadSeasons() {
    var data = await restGet('seasons', 'select=*&order=date.asc');
    seasons = (data || []).map(function(row) {
        return {
            id: row.id, game: row.game, name: row.name, date: row.date,
            players: row.players || [], isSpecial: row.is_special || false,
            specialNumber: row.special_number, organizer: row.organizer,
            speciality: row.speciality, gdocLink: row.gdoc_link
        };
    });
    console.log('[LOAD] seasons:', seasons.length);
}

async function loadDiscordProfiles() {
    var data = await restGet('discord_profiles', 'select=*');
    discordProfiles = {};
    discordAvatars = {};
    (data || []).forEach(function(row) {
        discordProfiles[row.pseudo] = row.discord_user_id;
        if (row.avatar_url) discordAvatars[row.discord_user_id] = row.avatar_url;
    });
    console.log('[LOAD] discord_profiles:', Object.keys(discordProfiles).length);
}

async function loadMergeHistory() {
    var data = await restGet('merge_history', 'select=*&order=merged_at.desc');
    mergeHistory = data || [];
    console.log('[LOAD] merge_history:', mergeHistory.length);
}

// ==================== UTILITY ====================
function detectGameType(seasonName) {
    const n = seasonName.toLowerCase();
    if (n.includes('kulture')) return 'Kulture';
    if (n.includes('hungerity')) return 'Hungerity';
    if (n.includes('pronostik')) return 'Pronostik';
    if (n.includes('guessw er') || n.includes('guessw-er') || n.includes('guesswer')) return 'GuessWer';
    if (n.includes('guessw at') || n.includes('guessw-at') || n.includes('guesswat')) return 'GuessWat';
    if (n.includes('guessw o') || n.includes('guessw-o') || n.includes('guesswo')) return 'GuessWo';
    if (n.includes('krossword') || n.includes('kross word')) return 'KrossWord';
    if (n.includes('ptibak')) return 'Ptibak';
    if (n.includes('justepoi') || n.includes('juste poi')) return 'Justepoi';
    if (n.includes('disgame')) return 'Disgame';
    if (n.includes('colanta')) return 'Colanta';
    if (n.includes('majority')) return 'Majority';
    return 'Majority';
}

function getGameSymbol(g) {
    if (!g) return '';
    const n = g.toLowerCase();
    if (n.includes('majority')) return ' \u{1F536}';
    if (n.includes('hungerity')) return ' \u{1F506}';
    if (n.includes('kulture')) return ' \u{1F7E4}';
    if (n.includes('guesswat')) return ' \u{1F310}';
    if (n.includes('pronostik')) return ' \u26BD';
    if (n.includes('guesswer')) return ' \u{1F30D}';
    if (n.includes('disgame')) return ' \u{1F47E}';
    if (n.includes('justepoi')) return ' \u{1F39F}';
    if (n.includes('krossword')) return ' \u274C';
    if (n.includes('ptibak')) return ' \u{1F521}';
    if (n.includes('colanta')) return ' \u{1F311}';
    if (n.includes('guesswo')) return ' \u{1F468}\u{1F3FC}';
    return '';
}

function getGameWithSymbol(g) { return g ? g + getGameSymbol(g) : ''; }

function getSeasonNumber(season) {
    const sorted = [...seasons].sort((a, b) => new Date(a.date) - new Date(b.date));
    return sorted.findIndex(s => s.name === season.name && s.date === season.date) + 1;
}

function parseNames(text) {
    return text.split('\n').map(l => {
        l = l.trim();
        if (!l) return null;
        // Strip leading rank with French ordinals: 1er, 2e, 3√®me, 2nd, 1¬∞, etc.
        l = l.replace(/^(TOP\s*)?\d+(?:er|[e√®](?:me|re)?|nde?|¬∞)?\s*[\s:.\-)\]]*\s*/gi, '');
        // Arrow separators (but NOT single > or | which are too aggressive)
        const arrowMatch = l.match(/[-=]>|\u2192|>>/);
        if (arrowMatch) l = l.substring(arrowMatch.index + arrowMatch[0].length).trim();
        // Handle pipe-separated columns: pick the column most likely to be a name
        if (l.includes('|')) {
            const cols = l.split('|').map(c => c.trim()).filter(c => c.length > 0);
            const nameCol = cols.find(c => /[a-zA-Z]/.test(c) && !/^\d+\s*(pts?|points?)?\s*$/i.test(c));
            if (nameCol) l = nameCol;
        }
        if (l.includes(':')) {
            const parts = l.split(':');
            if (parts[1] && /\d/.test(parts[1])) l = parts[0];
        }
        l = l.replace(/\s*\d+\s*pts?\.?$/i, '').replace(/\s*\d+\s*points?\.?$/i, '').replace(/\s+\d+$/, '').replace(/\s*\d+\s*pt$/i, '');
        l = l.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
        l = l.replace(/\([^)]*\)/g, '').replace(/\[[^\]]*\]/g, '').replace(/\{[^}]*\}/g, '');
        l = l.replace(/\*{1,2}([^*]+)\*{1,2}/g, '$1');
        l = l.replace(/\s*[-_=+~#@%&*!?]+\s*$/g, '').replace(/^[-_=+~#@%&*!?]+\s*/g, '');
        l = l.replace(/\.{2,}/g, '').replace(/[!?]{2,}/g, '');
        l = l.replace(/\s+/g, ' ').trim();
        l = l.replace(/^[^\w\s]+|[^\w\s]+$/gu, '').trim();
        return l.length >= 2 && /[a-zA-Z0-9_]/.test(l) ? l : null;
    }).filter(Boolean);
}

// ==================== UI HELPERS ====================
function showAdminTab(tab, btn) {
    document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(tab).classList.add('active');
    if (btn) btn.classList.add('active');
}

function showMsg(text, type) {
    const el = document.getElementById(type === 'success' ? 'successMsg' : 'errorMsg');
    el.textContent = text; el.style.display = 'block';
    if (type === 'success') document.getElementById('errorMsg').style.display = 'none';
    else document.getElementById('successMsg').style.display = 'none';
    setTimeout(() => el.style.display = 'none', 5000);
}

function showConfirm(msg, callback) {
    document.getElementById('confirmMsg').innerHTML = msg.replace(/\n/g, '<br>');
    document.getElementById('confirmModal').classList.add('active');
    confirmCb = callback;
}

function closeConfirm(confirmed) {
    document.getElementById('confirmModal').classList.remove('active');
    if (confirmCb) { confirmCb(confirmed); confirmCb = null; }
}

function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    localStorage.setItem('gammopDarkMode', document.body.classList.contains('dark-mode'));
}

// ==================== TAB 1: SAISONS ====================
function renderSeasonsList() {
    // Update Supabase count display
    var statusEl = document.getElementById('supabaseStatus');
    if (statusEl) {
        if (seasons.length > 0) {
            var games = {};
            seasons.forEach(function(s) { games[s.game] = (games[s.game] || 0) + 1; });
            var detail = Object.entries(games).map(function(e) { return e[0] + ': ' + e[1]; }).join(', ');
            statusEl.innerHTML = '<strong style="color:#4a7c28">Supabase: ' + seasons.length + ' saisons en base</strong> (' + detail + ')';
        } else {
            statusEl.innerHTML = '<strong style="color:#e74c3c">Supabase: 0 saisons en base</strong> ‚Äî importez via l\'onglet Backup ou ajoutez manuellement.';
        }
    }
    const el = document.getElementById('seasonsList');
    if (seasons.length === 0) { el.innerHTML = '<p style="color:var(--text-secondary)">Aucune saison</p>'; return; }

    const sorted = [...seasons].sort((a, b) => new Date(b.date) - new Date(a.date));
    el.innerHTML = sorted.map(s => {
        const date = new Date(s.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric' });
        const game = s.game || detectGameType(s.name);
        const num = getSeasonNumber(s);
        return `<div class="season-card">
            <div>
                <h4>${s.name} <span style="background:#667eea;color:white;padding:2px 8px;border-radius:4px;font-size:0.85em;font-weight:600;margin-left:8px">n\u00B0${num}</span></h4>
                <p>${date} \u2022 <span style="background:#4a7c28;color:white;padding:2px 8px;border-radius:4px;font-size:0.9em;font-weight:600">${getGameWithSymbol(game)}</span> \u2022 ${s.players.length} joueurs</p>
            </div>
            <div class="season-actions">
                <button class="btn btn-secondary" onclick="editSeason('${s.id}')">\u270F\uFE0F Modifier</button>
                <button class="btn btn-danger" onclick="deleteSeason('${s.id}')">\u{1F5D1}\uFE0F Supprimer</button>
            </div>
        </div>`;
    }).join('');
}

function editSeason(id) {
    const s = seasons.find(x => x.id === id);
    if (!s) return;

    editingSeasonId = id;
    showAdminTab('add', document.querySelectorAll('.tab-btn')[1]);

    document.getElementById('addTitle').textContent = 'Modifier la Saison';
    document.getElementById('addBtn').textContent = 'Enregistrer les Modifications';
    document.getElementById('cancelEditBtn').style.display = '';

    document.getElementById('isSpecialSeason').checked = s.isSpecial || false;
    toggleSpecialSeasonFields();
    document.getElementById('seasonGame').value = s.game || detectGameType(s.name);

    if (s.isSpecial) {
        document.getElementById('specialSeasonNumber').value = s.specialNumber || '';
        if (s.organizer) {
            const radio = document.querySelector('input[name="specialityType"][value="organizer"]');
            if (radio) { radio.checked = true; toggleSpecialityFields(); }
            document.getElementById('organizerName').value = s.organizer;
        } else if (s.speciality) {
            const radio = document.querySelector('input[name="specialityType"][value="other"]');
            if (radio) { radio.checked = true; toggleSpecialityFields(); }
            document.getElementById('otherSpeciality').value = s.speciality;
        }
    } else {
        const match = s.name.match(/Saison (\d+)/);
        document.getElementById('seasonNumber').value = match ? match[1] : '1';
    }

    document.getElementById('seasonDate').value = s.date;
    document.getElementById('seasonGdocLink').value = s.gdocLink || '';
    document.getElementById('seasonRanking').value = s.players.join('\n');
}

function cancelEdit() {
    editingSeasonId = null;
    document.getElementById('addTitle').textContent = 'Ajouter une Saison';
    document.getElementById('addBtn').textContent = 'Ajouter la Saison';
    document.getElementById('cancelEditBtn').style.display = 'none';
    resetAddForm();
    showAdminTab('seasons', document.querySelectorAll('.tab-btn')[0]);
}

async function deleteSeason(id) {
    const s = seasons.find(x => x.id === id);
    if (!s) return;
    if (!currentSession) { showMsg('Non connecte ‚Äî reconnectez-vous.', 'error'); return; }
    showConfirm(`Supprimer "${s.name}" ?\nCette action est irreversible.`, async (confirmed) => {
        if (!confirmed) return;
        try {
            await restDelete('seasons', id);
        } catch (err) { showMsg('Erreur suppression: ' + err.message, 'error'); return; }
        await loadSeasons();
        renderSeasonsList();
        showMsg(`"${s.name}" supprimee. Total en base: ${seasons.length} saisons.`, 'success');
    });
}

// ==================== TAB 2: AJOUTER ====================
function toggleSpecialSeasonFields() {
    const isSpecial = document.getElementById('isSpecialSeason').checked;
    document.getElementById('normalSeasonNumberGroup').style.display = isSpecial ? 'none' : '';
    document.getElementById('specialSeasonNumberGroup').style.display = isSpecial ? '' : 'none';
    document.getElementById('specialityGroup').style.display = isSpecial ? '' : 'none';
    if (!isSpecial) {
        document.getElementById('organizerName').value = '';
        document.getElementById('otherSpeciality').value = '';
        document.querySelectorAll('input[name="specialityType"]').forEach(r => r.checked = false);
        document.getElementById('organizerField').style.display = 'none';
        document.getElementById('otherSpecialityField').style.display = 'none';
    }
}

function toggleSpecialityFields() {
    const sel = document.querySelector('input[name="specialityType"]:checked');
    if (!sel) return;
    document.getElementById('organizerField').style.display = sel.value === 'organizer' ? '' : 'none';
    document.getElementById('otherSpecialityField').style.display = sel.value === 'other' ? '' : 'none';
}

function resetAddForm() {
    document.getElementById('seasonGame').value = 'Majority';
    document.getElementById('seasonNumber').value = '';
    document.getElementById('specialSeasonNumber').value = '';
    document.getElementById('seasonDate').value = new Date().toISOString().split('T')[0];
    document.getElementById('seasonGdocLink').value = '';
    document.getElementById('seasonRanking').value = '';
    document.getElementById('isSpecialSeason').checked = false;
    document.getElementById('organizerName').value = '';
    document.getElementById('otherSpeciality').value = '';
    document.querySelectorAll('input[name="specialityType"]').forEach(r => r.checked = false);
    toggleSpecialSeasonFields();
}

async function addSeason() {
    // 1. Check cached session
    if (!currentSession) {
        showMsg('Non connecte ‚Äî reconnectez-vous avant d\'ajouter une saison.', 'error');
        return;
    }

    const game = document.getElementById('seasonGame').value;
    const isSpecial = document.getElementById('isSpecialSeason').checked;
    const number = isSpecial
        ? document.getElementById('specialSeasonNumber').value
        : document.getElementById('seasonNumber').value;
    const date = document.getElementById('seasonDate').value;
    const gdocLink = document.getElementById('seasonGdocLink').value.trim();
    const text = document.getElementById('seasonRanking').value.trim();

    if (!game || !number || !date || !text) { showMsg('Tous les champs sont requis', 'error'); return; }

    const players = parseNames(text);
    if (players.length === 0) { showMsg('Aucun pseudo trouve', 'error'); return; }

    const name = isSpecial ? `${game} #${number}` : `${game} Saison ${number}`;

    const row = {
        game, name, date, players,
        is_special: isSpecial,
        special_number: isSpecial ? parseInt(number) : null,
        gdoc_link: gdocLink || null,
        organizer: null, speciality: null
    };

    if (isSpecial) {
        const specType = document.querySelector('input[name="specialityType"]:checked');
        if (specType) {
            if (specType.value === 'organizer') row.organizer = document.getElementById('organizerName').value.trim() || null;
            else if (specType.value === 'other') row.speciality = document.getElementById('otherSpeciality').value.trim() || null;
        }
    }

    // 2. Write via REST API
    try {
        if (editingSeasonId) {
            await restPatch('seasons', editingSeasonId, row);
            editingSeasonId = null;
            document.getElementById('addTitle').textContent = 'Ajouter une Saison';
            document.getElementById('addBtn').textContent = 'Ajouter la Saison';
            document.getElementById('cancelEditBtn').style.display = 'none';
        } else {
            await restPost('seasons', row);
        }
    } catch (err) {
        showMsg('Erreur Supabase: ' + err.message, 'error');
        return;
    }

    // 3. Reload and show count
    resetAddForm();
    await loadSeasons();
    renderSeasonsList();
    updatePseudosList();

    const typeMsg = isSpecial ? 'speciale ' : '';
    showMsg(`Saison ${typeMsg}"${name}" enregistree (${players.length} joueurs). Total en base: ${seasons.length} saisons.`, 'success');
    setTimeout(() => showAdminTab('seasons', document.querySelectorAll('.tab-btn')[0]), 2000);
}

// ==================== TAB 3: PSEUDOS ====================
function getAllPseudos() {
    const pseudos = new Set();
    seasons.forEach(s => s.players.forEach(p => pseudos.add(p)));
    return Array.from(pseudos).sort();
}

function updatePseudosList() {
    const sel = document.getElementById('oldPseudo');
    const discordSel = document.getElementById('discordPseudo');
    const pseudos = getAllPseudos();

    sel.innerHTML = '<option value="">-- Selectionner --</option>';
    discordSel.innerHTML = '<option value="">-- Selectionner un pseudo --</option>';

    pseudos.forEach(p => {
        sel.innerHTML += `<option value="${p}">${p}</option>`;
        discordSel.innerHTML += `<option value="${p}">${p}</option>`;
    });
}

// --- Similar Pseudos ---
function levenshteinDistance(str1, str2) {
    const len1 = str1.length, len2 = str2.length;
    const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(0));
    for (let i = 0; i <= len1; i++) matrix[0][i] = i;
    for (let j = 0; j <= len2; j++) matrix[j][0] = j;
    for (let j = 1; j <= len2; j++) {
        for (let i = 1; i <= len1; i++) {
            const cost = str1[i-1] === str2[j-1] ? 0 : 1;
            matrix[j][i] = Math.min(matrix[j][i-1]+1, matrix[j-1][i]+1, matrix[j-1][i-1]+cost);
        }
    }
    return matrix[len2][len1];
}

function arePseudosSimilar(p1, p2) {
    const a = p1.toLowerCase().trim(), b = p2.toLowerCase().trim();
    if (a === b) return true;
    if (a.replace(/\s+/g, '') === b.replace(/\s+/g, '')) return true;
    const ac = a.replace(/[^a-z0-9]/g, ''), bc = b.replace(/[^a-z0-9]/g, '');
    if (ac === bc && ac.length > 0) return true;
    if (p1.length > 4 && p2.length > 4 && levenshteinDistance(a, b) <= 2) return true;
    if ((p1.length <= 4 || p2.length <= 4) && levenshteinDistance(a, b) === 1) return true;
    return false;
}

function updateSimilarPseudos() {
    const container = document.getElementById('similarPseudos');
    const pseudoArray = getAllPseudos();

    const graph = new Map();
    pseudoArray.forEach(p => graph.set(p, new Set()));
    for (let i = 0; i < pseudoArray.length; i++) {
        for (let j = i + 1; j < pseudoArray.length; j++) {
            const pairKey = [pseudoArray[i], pseudoArray[j]].sort().join('|||');
            if (!ignoredPairs.has(pairKey) && arePseudosSimilar(pseudoArray[i], pseudoArray[j])) {
                graph.get(pseudoArray[i]).add(pseudoArray[j]);
                graph.get(pseudoArray[j]).add(pseudoArray[i]);
            }
        }
    }

    const visited = new Set();
    const groups = [];
    function dfs(pseudo, group) {
        visited.add(pseudo); group.push(pseudo);
        graph.get(pseudo).forEach(n => { if (!visited.has(n)) dfs(n, group); });
    }
    pseudoArray.forEach(p => {
        if (!visited.has(p) && graph.get(p).size > 0) {
            const group = []; dfs(p, group);
            if (group.length > 1) groups.push(group.sort());
        }
    });

    currentSimilarGroups = groups;

    if (groups.length === 0) {
        container.innerHTML = '<p style="color:#4a7c28;padding:20px;text-align:center;background:var(--section-bg);border-radius:8px">Aucun pseudo similaire detecte</p>';
        return;
    }

    container.innerHTML = groups.map((group, gIdx) => {
        let html = '<div style="background:#fff3cd;border:2px solid #ffc107;border-radius:10px;padding:20px;margin-bottom:15px">';
        html += '<div style="font-size:1.1em;font-weight:bold;color:#2d5016;margin-bottom:10px">Groupe de pseudos similaires :</div>';
        html += '<div style="display:flex;flex-direction:column;gap:8px;margin-bottom:15px">';
        group.forEach((p, idx) => {
            const escaped = p.replace(/"/g, '&quot;');
            html += `<label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:8px;background:white;border-radius:6px;border:1px solid #ddd">
                <input type="checkbox" id="pseudo_${gIdx}_${idx}" value="${escaped}" checked style="width:18px;height:18px;cursor:pointer">
                <span style="font-weight:600;color:#2d5016">${p}</span></label>`;
        });
        html += '</div>';
        html += `<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:end">
            <div style="flex:1;min-width:200px">
                <label style="display:block;font-size:0.9em;color:#666;margin-bottom:5px;font-weight:600">Regrouper sur :</label>
                <input type="text" id="mergeTarget_${gIdx}" placeholder="Pseudo final" style="width:100%;padding:10px;border:2px solid #ddd;border-radius:6px">
            </div>
            <button class="btn btn-primary" onclick="mergeSelectedPseudos(${gIdx})">Regrouper</button>
            <button class="btn btn-secondary" onclick="ignoreGroup(${gIdx})">Ignorer</button>
        </div></div>`;
        return html;
    }).join('');
}

async function mergeSelectedPseudos(gIdx) {
    const group = currentSimilarGroups[gIdx];
    const selected = [];
    group.forEach((p, idx) => {
        const cb = document.getElementById(`pseudo_${gIdx}_${idx}`);
        if (cb && cb.checked) selected.push(p);
    });
    if (selected.length < 2) { alert('Selectionnez au moins 2 pseudos'); return; }

    const target = document.getElementById(`mergeTarget_${gIdx}`)?.value.trim();
    if (!target) { alert('Entrez le pseudo final'); return; }

    if (!confirm(`Regrouper "${selected.join('", "')}" sous "${target}" ?`)) return;

    // Update all affected seasons
    const affected = seasons.filter(s => s.players.some(p => selected.includes(p)));
    for (const s of affected) {
        const newPlayers = s.players.map(p => selected.includes(p) ? target : p);
        const seen = new Set(); const deduped = newPlayers.filter(p => { if (seen.has(p)) return false; seen.add(p); return true; });
        try { await restPatch('seasons', s.id, { players: deduped }); } catch(e) { console.error('Error updating season:', e); }
    }

    // Update discord profiles
    for (const p of selected) {
        if (p !== target && discordProfiles[p]) {
            try { await restPatchWhere('discord_profiles', 'pseudo=eq.' + encodeURIComponent(p), { pseudo: target }); } catch(e) { console.error(e); }
        }
    }

    // Record merge
    try { await restPost('merge_history', { source_pseudos: selected, target_pseudo: target }); } catch(e) { console.error(e); }

    // Ignore pairs
    for (let i = 0; i < selected.length; i++) {
        for (let j = i + 1; j < selected.length; j++) {
            ignoredPairs.add([selected[i], selected[j]].sort().join('|||'));
        }
    }

    await loadAllData();
    alert(`Pseudos regroupes sous "${target}"`);
}

function ignoreGroup(gIdx) {
    const group = currentSimilarGroups[gIdx];
    for (let i = 0; i < group.length; i++) {
        for (let j = i + 1; j < group.length; j++) {
            ignoredPairs.add([group[i], group[j]].sort().join('|||'));
        }
    }
    updateSimilarPseudos();
}

// --- Discord Profiles ---
async function linkDiscordProfile() {
    const pseudo = document.getElementById('discordPseudo')?.value;
    const userId = document.getElementById('discordUserId')?.value.trim();
    if (!pseudo || !userId) { showDiscordMsg('Remplissez les deux champs', 'error'); return; }
    if (!/^\d+$/.test(userId)) { showDiscordMsg('L\'ID Discord doit etre numerique', 'error'); return; }

    showDiscordMsg('Recuperation de l\'avatar...', 'success');

    let avatarUrl = null;
    try {
        var avatarResp = await fetch(SUPABASE_URL + '/functions/v1/discord-avatar', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ userId })
        });
        if (avatarResp.ok) { var avatarData = await avatarResp.json(); if (avatarData.avatarUrl) avatarUrl = avatarData.avatarUrl; }
    } catch (e) { console.warn('Edge function error:', e); }

    try {
        await restUpsert('discord_profiles', { pseudo, discord_user_id: userId, avatar_url: avatarUrl });
    } catch (err) { showDiscordMsg('Erreur: ' + err.message, 'error'); return; }

    document.getElementById('discordPseudo').value = '';
    document.getElementById('discordUserId').value = '';
    await loadDiscordProfiles();
    renderDiscordProfilesList();
    showDiscordMsg(`Profil Discord lie pour ${pseudo}`, 'success');
}

async function unlinkDiscordProfile(pseudo) {
    if (!confirm(`Supprimer la liaison Discord pour "${pseudo}" ?`)) return;
    try {
        await restDeleteWhere('discord_profiles', 'pseudo=eq.' + encodeURIComponent(pseudo));
    } catch (err) { showDiscordMsg('Erreur: ' + err.message, 'error'); return; }
    await loadDiscordProfiles();
    renderDiscordProfilesList();
    showDiscordMsg(`Liaison supprimee pour ${pseudo}`, 'success');
}

function renderDiscordProfilesList() {
    const container = document.getElementById('discordProfilesList');
    const entries = Object.entries(discordProfiles);
    if (entries.length === 0) {
        container.innerHTML = '<p style="color:var(--text-secondary);text-align:center;padding:15px;background:var(--bg-secondary);border-radius:8px">Aucun profil Discord lie</p>';
        return;
    }
    container.innerHTML = '<div style="display:grid;gap:10px">' + entries.map(([pseudo, userId]) => {
        const avatarUrl = discordAvatars[userId] || `https://cdn.discordapp.com/embed/avatars/${parseInt(userId) % 5}.png`;
        return `<div style="display:flex;align-items:center;justify-content:space-between;padding:12px;background:var(--section-bg);border:2px solid var(--section-border);border-radius:8px">
            <div style="display:flex;align-items:center;gap:12px">
                <img src="${avatarUrl}" alt="${pseudo}" style="width:32px;height:32px;border-radius:50%;background:#ddd" onerror="this.onerror=null;this.src='https://cdn.discordapp.com/embed/avatars/${parseInt(userId) % 5}.png'">
                <div><div style="font-weight:600;color:var(--text-accent)">${pseudo}</div><div style="font-size:0.85em;color:var(--text-secondary)">ID: ${userId}</div></div>
            </div>
            <button class="btn btn-danger" onclick="unlinkDiscordProfile('${pseudo.replace(/'/g, "\\'")}')">Supprimer</button>
        </div>`;
    }).join('') + '</div>';
}

function showDiscordMsg(msg, type) {
    const s = document.getElementById('discordSuccess'), e = document.getElementById('discordError');
    if (type === 'success') { s.textContent = msg; s.style.display = 'block'; e.style.display = 'none'; setTimeout(() => s.style.display = 'none', 5000); }
    else { e.textContent = msg; e.style.display = 'block'; s.style.display = 'none'; setTimeout(() => e.style.display = 'none', 5000); }
}

// --- Undo Merge ---
function renderMergeHistory() {
    const container = document.getElementById('mergeHistoryList');
    if (mergeHistory.length === 0) {
        container.innerHTML = '<p style="color:var(--text-secondary);text-align:center;padding:20px;background:var(--bg-secondary);border-radius:8px">Aucun regroupement effectue</p>';
        return;
    }
    container.innerHTML = mergeHistory.map(record => {
        const sources = record.source_pseudos.join(', ');
        const date = new Date(record.merged_at).toLocaleString('fr-FR');
        return `<div style="background:#fff3cd;border:2px solid #ffc107;border-radius:10px;padding:20px;margin-bottom:15px">
            <div style="display:flex;justify-content:space-between;align-items:start">
                <div style="flex:1">
                    <div style="font-weight:bold;color:#2d5016;margin-bottom:5px">Regroupement vers "${record.target_pseudo}"</div>
                    <div style="color:var(--text-secondary);font-size:0.9em;margin-bottom:8px">${date}</div>
                    <div style="background:white;padding:10px;border-radius:6px;border:1px solid #ddd">
                        <div style="color:var(--text-secondary);font-size:0.85em;margin-bottom:5px">Pseudos regroupes :</div>
                        <div style="font-weight:600;color:#2d5016">${sources}</div>
                    </div>
                </div>
                <button class="btn btn-danger" onclick="undoMerge('${record.id}')" style="margin-left:15px;white-space:nowrap">Annuler</button>
            </div>
        </div>`;
    }).join('');
}

async function undoMerge(mergeId) {
    const record = mergeHistory.find(r => r.id === mergeId);
    if (!record) return;

    if (!confirm(`Annuler le regroupement vers "${record.target_pseudo}" ?\nCela va redistribuer les pseudos sources de maniere cyclique.`)) return;

    let sourceIdx = 0;
    const affected = seasons.filter(s => s.players.includes(record.target_pseudo));
    for (const s of affected) {
        const newPlayers = s.players.map(p => {
            if (p === record.target_pseudo) {
                const src = record.source_pseudos[sourceIdx % record.source_pseudos.length];
                sourceIdx++;
                return src;
            }
            return p;
        });
        try { await restPatch('seasons', s.id, { players: newPlayers }); } catch(e) { console.error('Error undoing merge:', e); }
    }

    try { await restDelete('merge_history', mergeId); } catch(e) { console.error(e); }
    await loadAllData();
    showUndoMergeMsg('Regroupement annule avec succes', 'success');
}

function showUndoMergeMsg(msg, type) {
    const s = document.getElementById('undoMergeSuccess'), e = document.getElementById('undoMergeError');
    if (type === 'success') { s.textContent = msg; s.style.display = 'block'; e.style.display = 'none'; setTimeout(() => s.style.display = 'none', 5000); }
    else { e.textContent = msg; e.style.display = 'block'; s.style.display = 'none'; setTimeout(() => e.style.display = 'none', 5000); }
}

// --- Rename ---
function previewRename() {
    const old = document.getElementById('oldPseudo')?.value;
    const newP = document.getElementById('newPseudo')?.value.trim();
    const preview = document.getElementById('preview');
    if (!old || !newP || !preview) { if (preview) preview.style.display = 'none'; return; }
    let count = 0; const affected = [];
    seasons.forEach(s => { if (s.players.includes(old)) { count++; affected.push(s.name); } });
    if (count === 0) { preview.innerHTML = '<p style="color:#e57373">Aucune occurrence</p>'; }
    else { preview.innerHTML = `<p><strong>${old}</strong> \u2192 <strong style="color:#4a7c28">${newP}</strong></p><p style="color:var(--text-secondary)">Trouve dans <strong>${count}</strong> saison(s)</p><ul style="color:var(--text-secondary);margin-left:20px;margin-top:5px">${affected.map(s => `<li>${s}</li>`).join('')}</ul>`; }
    preview.style.display = 'block';
}

async function renamePseudo() {
    const old = document.getElementById('oldPseudo')?.value;
    const newP = document.getElementById('newPseudo')?.value.trim();
    if (!old || !newP) { showPseudoMsg('Remplir les deux champs', 'error'); return; }
    if (old === newP) { showPseudoMsg('Pseudos identiques', 'error'); return; }

    const affected = seasons.filter(s => s.players.includes(old));
    if (affected.length === 0) { showPseudoMsg('Pseudo introuvable', 'error'); return; }

    showConfirm(`Renommer "${old}" \u2192 "${newP}" ?\nAffectera ${affected.length} saison(s).\nAction irreversible.`, async (confirmed) => {
        if (!confirmed) return;

        for (const s of affected) {
            const newPlayers = s.players.map(p => p === old ? newP : p);
            try { await restPatch('seasons', s.id, { players: newPlayers }); } catch(e) { console.error('Error renaming:', e); }
        }

        // Update discord profile if exists
        if (discordProfiles[old]) {
            try { await restPatchWhere('discord_profiles', 'pseudo=eq.' + encodeURIComponent(old), { pseudo: newP }); } catch(e) { console.error(e); }
        }

        document.getElementById('oldPseudo').value = '';
        document.getElementById('newPseudo').value = '';
        document.getElementById('preview').style.display = 'none';
        await loadAllData();
        showPseudoMsg(`Pseudo renomme (${affected.length} saison(s))`, 'success');
    });
}

function cancelRename() {
    document.getElementById('oldPseudo').value = '';
    document.getElementById('newPseudo').value = '';
    document.getElementById('preview').style.display = 'none';
}

function showPseudoMsg(text, type) {
    const s = document.getElementById('pseudoSuccess'), e = document.getElementById('pseudoError');
    if (type === 'success') { s.textContent = text; s.style.display = 'block'; e.style.display = 'none'; }
    else { e.textContent = text; e.style.display = 'block'; s.style.display = 'none'; }
    setTimeout(() => { s.style.display = 'none'; e.style.display = 'none'; }, 5000);
}

// ==================== TAB 4: BACKUP ====================
function getBackupData() {
    return {
        version: 2,
        seasons: seasons.map(s => ({
            game: s.game, name: s.name, date: s.date, players: s.players,
            isSpecial: s.isSpecial || false, specialNumber: s.specialNumber,
            organizer: s.organizer, speciality: s.speciality, gdocLink: s.gdocLink
        })),
        discordProfiles: { ...discordProfiles },
        discordAvatars: { ...discordAvatars }
    };
}

function exportToClipboard() {
    const data = JSON.stringify(getBackupData(), null, 2);
    navigator.clipboard.writeText(data).then(() => {
        showBackupMsg('Donnees copiees (saisons + profils Discord)', 'success');
    }).catch(() => showBackupMsg('Erreur lors de la copie', 'error'));
}

function downloadBackup() {
    const data = JSON.stringify(getBackupData(), null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `gammop-backup-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    showBackupMsg('Fichier telecharge', 'success');
}

// --- Import log helper ---
function importLog(msg) {
    console.log(msg);
    var el = document.getElementById('importLog');
    if (el) { el.style.display = 'block'; el.textContent += msg + '\n'; }
}
function clearImportLog() {
    var el = document.getElementById('importLog');
    if (el) { el.textContent = ''; el.style.display = 'none'; }
}

async function callEdgeFunction(payload) {
    // Helper: timeout wrapper for any promise
    function withTimeout(promise, ms, label) {
        return Promise.race([
            promise,
            new Promise(function(_, reject) {
                setTimeout(function() { reject(new Error('TIMEOUT apres ' + (ms/1000) + 's sur: ' + label)); }, ms);
            })
        ]);
    }

    // 1. Use cached session (set by onAuthStateChange / checkSession / handleHashCallback)
    importLog('[EDGE] 1/4 - Verification session...');
    var session = currentSession;
    if (!session || !session.access_token) {
        throw new Error('Non connecte (session absente). Reconnectez-vous (GitHub / Magic Link).');
    }

    var url = SUPABASE_URL + '/functions/v1/import-seasons';
    importLog('[EDGE] 2/4 - Session OK: ' + (session.user.email || session.user.id));
    importLog('[EDGE] URL: ' + url);
    importLog('[EDGE] Mode: ' + (payload.mode || 'replace'));
    console.log('[EDGE] Calling:', url, 'mode:', payload.mode);

    // 2. Call Edge Function (timeout 30s)
    // Pas de Authorization header (JWT verification desactivee sur la fonction)
    // Le JWT utilisateur est envoye dans le body (verifie par la Edge Function elle-meme)
    var bodyWithJwt = Object.assign({}, payload, { userJwt: session.access_token });
    importLog('[EDGE] 3/4 - Appel fetch...');
    var response;
    try {
        response = await withTimeout(
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(bodyWithJwt)
            }),
            30000,
            'fetch Edge Function'
        );
    } catch (networkErr) {
        importLog('[EDGE] ERREUR: ' + networkErr.message);
        console.error('[EDGE] Fetch error:', networkErr);
        throw new Error(networkErr.message + '. La Edge Function est-elle deployee ? Verifiez Supabase > Edge Functions.');
    }

    importLog('[EDGE] HTTP ' + response.status + ' ' + response.statusText);
    console.log('[EDGE] Response:', response.status, response.statusText);

    // 3. Parse response body
    importLog('[EDGE] 4/4 - Lecture reponse...');
    var rawBody;
    try {
        rawBody = await withTimeout(response.text(), 5000, 'response.text()');
    } catch (e) {
        throw new Error('Impossible de lire la reponse: ' + e.message);
    }

    importLog('[EDGE] Body: ' + rawBody.substring(0, 500));
    console.log('[EDGE] Body:', rawBody);

    var result;
    try {
        result = JSON.parse(rawBody);
    } catch (parseErr) {
        throw new Error('Reponse non-JSON (HTTP ' + response.status + '). Body: ' + rawBody.substring(0, 300));
    }

    // 4. Check HTTP status
    if (!response.ok) {
        var errMsg = result.error || 'Erreur ' + response.status;
        if (result.details) errMsg += ' ‚Äî ' + result.details;
        errMsg += ' [HTTP ' + response.status + ']';
        throw new Error(errMsg);
    }

    importLog('[EDGE] OK !');
    return result;
}

// Verification independante : count(*) via REST API (pas le SDK)
async function verifyDbCount() {
    try {
        var resp = await fetch(REST_BASE + '/seasons?select=id&limit=0', {
            method: 'HEAD',
            headers: Object.assign({ 'Prefer': 'count=exact' }, REST_HEADERS)
        });
        // PostgREST renvoie le count dans le header Content-Range
        var range = resp.headers.get('content-range');
        if (range) {
            var total = parseInt(range.split('/')[1]);
            importLog('[VERIFY] Supabase seasons count = ' + total);
            return total;
        }
        // Fallback: compter les rows
        var data = await restGet('seasons', 'select=id');
        importLog('[VERIFY] Supabase seasons count = ' + data.length + ' (fallback)');
        return data.length;
    } catch (e) {
        importLog('[VERIFY] Exception: ' + e.message);
        return -1;
    }
}

async function processImportData(parsed) {
    clearImportLog();
    var importSeasons, importProfiles = {}, importAvatars = {};

    // --- Parse format ---
    if (Array.isArray(parsed)) {
        importSeasons = parsed;
    } else if (parsed && parsed.version === 2 && Array.isArray(parsed.seasons)) {
        importSeasons = parsed.seasons;
        importProfiles = parsed.discordProfiles || {};
        importAvatars = parsed.discordAvatars || {};
    } else {
        showBackupMsg('Format JSON non reconnu (ni tableau, ni objet version:2 avec .seasons)', 'error');
        return false;
    }

    importLog('[IMPORT] JSON rows parsed: ' + importSeasons.length);

    // Validate sample
    if (importSeasons.length > 0) {
        var sample = importSeasons[0];
        importLog('[IMPORT] Sample: ' + JSON.stringify(sample).substring(0, 200));
        if (!sample.name || !sample.date || !sample.players) {
            showBackupMsg('ERREUR: Champs manquants. Chaque saison doit avoir: name, date, players.', 'error');
            return false;
        }
    }

    if (!confirm('Importer ' + importSeasons.length + ' saison(s) ?\nCela REMPLACERA toutes les donnees existantes.')) return 'cancelled';

    // Build rows with correct DB column names
    var rows = importSeasons.map(function(s) {
        return {
            game: s.game || detectGameType(s.name),
            name: s.name,
            date: s.date,
            players: s.players,
            is_special: s.isSpecial || s.is_special || false,
            special_number: s.specialNumber || s.special_number || null,
            organizer: s.organizer || null,
            speciality: s.speciality || null,
            gdoc_link: s.gdocLink || s.gdoc_link || null
        };
    });

    // Build profiles array
    var profiles = Object.entries(importProfiles).map(function(entry) {
        return { pseudo: entry[0], discord_user_id: entry[1], avatar_url: importAvatars[entry[1]] || null };
    });

    importLog('[IMPORT] ' + rows.length + ' seasons + ' + profiles.length + ' profiles a envoyer');

    try {
        var result = await callEdgeFunction({
            mode: 'replace',
            seasons: rows,
            profiles: profiles
        });

        importLog('[EDGE] Reponse: inserted=' + result.inserted + ', verified=' + result.verified + ', profiles=' + (result.profilesInserted || 0));

        // Verification independante (peut timeout si SDK hang)
        var dbCount = await verifyDbCount();

        if (dbCount === 0 && result.verified === 0) {
            showBackupMsg('ECHEC CRITIQUE : inserted=' + result.inserted + ' mais count(*) = 0. Rien ecrit en base.', 'error');
            importLog('[IMPORT] ECHEC: count(*) = 0 malgre inserted=' + result.inserted);
            return false;
        }

        // Se fier au verified de la Edge Function si le SDK front hang
        var finalCount = dbCount >= 0 ? dbCount : result.verified;
        return { inserted: result.inserted, verified: finalCount };
    } catch (err) {
        showBackupMsg('ERREUR Edge Function: ' + err.message, 'error');
        importLog('[EDGE] ERREUR: ' + err.message);
        return false;
    }
}

async function importFromText() {
    var text = document.getElementById('importData').value.trim();
    if (!text) { showBackupMsg('Collez des donnees JSON', 'error'); return; }
    try {
        var parsed = JSON.parse(text);
        var result = await processImportData(parsed);
        if (result === 'cancelled') return;
        if (!result) return;
        document.getElementById('importData').value = '';
        try {
            await Promise.race([loadAllData(), new Promise(function(_, rej) { setTimeout(function() { rej(new Error('timeout')); }, 8000); })]);
        } catch(e) { importLog('[IMPORT] loadAllData timeout ‚Äî SDK instable.'); }
        showBackupMsg('Import OK ! Edge Function verified = ' + result.verified + ' seasons.' + (seasons.length > 0 ? ' Admin: ' + seasons.length + ' chargees.' : ' (rechargez la page pour voir la liste)'), 'success');
    } catch (e) { showBackupMsg('JSON invalide: ' + e.message, 'error'); }
}

async function importFromFile(event) {
    var file = event.target.files[0];
    if (!file) return;
    var reader = new FileReader();
    reader.onload = async function(e) {
        try {
            var parsed = JSON.parse(e.target.result);
            var result = await processImportData(parsed);
            if (result === 'cancelled') return;
            if (!result) return;
            try {
                await Promise.race([loadAllData(), new Promise(function(_, rej) { setTimeout(function() { rej(new Error('timeout')); }, 8000); })]);
            } catch(e2) { importLog('[IMPORT] loadAllData timeout ‚Äî SDK instable.'); }
            showBackupMsg('Import OK ! Edge Function verified = ' + result.verified + ' seasons.' + (seasons.length > 0 ? ' Admin: ' + seasons.length + ' chargees.' : ' (rechargez la page pour voir la liste)'), 'success');
        } catch (err) { showBackupMsg('Erreur lecture fichier: ' + err.message, 'error'); }
    };
    reader.readAsText(file);
    event.target.value = '';
}

// --- Test: insert 1 season via Edge Function ---
async function testInsertOneSeason() {
    var el = document.getElementById('testResult');
    if (!el) { alert('Element #testResult introuvable'); return; }

    try {
        el.innerHTML = '<span style="color:orange">Test en cours via Edge Function...</span>';
        clearImportLog();
        importLog('[TEST] Debut du test...');

        var result = await callEdgeFunction({ mode: 'test' });

        importLog('[TEST] Reponse: ' + JSON.stringify(result));

        // Verification independante (peut timeout si SDK hang)
        importLog('[TEST] Verification count(*)...');
        var dbCount = await verifyDbCount();
        var countMsg = dbCount >= 0 ? ('count(*) = ' + dbCount) : ('count(*) indisponible ‚Äî voir Edge Function verified=' + result.verified);

        if (dbCount === 0 && result.verified === 0) {
            el.innerHTML = '<span style="color:red">ECHEC : inserted=' + result.inserted
                + ' mais count(*) = 0. Rien ecrit en base !</span>';
            return;
        }

        el.innerHTML = '<span style="color:green">SUCCES ! Row inseree via Edge Function.'
            + '<br>Edge Function: inserted=' + result.inserted + ', verified=' + result.verified
            + '<br>Verification admin: ' + countMsg
            + '<br>User: ' + result.user
            + '<br>Verifiez dans Supabase > Table Editor > seasons.</span>';

        // Reload (avec timeout car loadAllData utilise aussi le SDK)
        try {
            await Promise.race([loadAllData(), new Promise(function(_, rej) { setTimeout(function() { rej(new Error('timeout')); }, 8000); })]);
        } catch(e) {
            importLog('[TEST] loadAllData timeout ‚Äî le SDK front-end est instable, mais la Edge Function a ecrit.');
        }
    } catch (err) {
        console.error('[TEST] Exception:', err);
        importLog('[TEST] ERREUR: ' + (err.message || String(err)));
        el.innerHTML = '<span style="color:red">ECHEC: ' + (err.message || String(err))
            + '</span><br><small style="color:#999">Voir le log ci-dessous et la console (F12) pour details.</small>';
    }
}

function showBackupMsg(text, type) {
    var s = document.getElementById('backupSuccess'), e = document.getElementById('backupError');
    if (type === 'success') { s.textContent = text; s.style.display = 'block'; e.style.display = 'none'; }
    else { e.textContent = text; e.style.display = 'block'; s.style.display = 'none'; }
}

// ==================== PTIBAK ====================
var ptibakState = null;

function ptibakStart() {
    var countInput = document.getElementById('ptibakPlayerCount');
    var namesInput = document.getElementById('ptibakPlayerNames');
    var qualifPtsInput = document.getElementById('ptibakQualifPoints');
    var qualifSlotsInput = document.getElementById('ptibakQualifSlots');

    var count = parseInt(countInput.value) || 6;
    var qualifPts = parseInt(qualifPtsInput.value) || 7;
    var qualifSlots = parseInt(qualifSlotsInput.value) || 3;

    var names = namesInput.value.trim().split('\n').map(function(n) { return n.trim(); }).filter(function(n) { return n.length > 0; });

    if (names.length < 2) {
        alert('Il faut au moins 2 joueurs !');
        return;
    }
    if (names.length > 30) {
        alert('Maximum 30 joueurs !');
        return;
    }

    // Check for duplicates
    var seen = {};
    for (var i = 0; i < names.length; i++) {
        var lower = names[i].toLowerCase();
        if (seen[lower]) {
            alert('Nom en double : ' + names[i]);
            return;
        }
        seen[lower] = true;
    }

    ptibakState = {
        players: names.map(function(name) { return { name: name, points: 0 }; }),
        qualifPoints: qualifPts,
        qualifSlots: qualifSlots,
        roundNumber: 0,
        history: [],       // array of arrays: each entry is the round points awarded
        currentRound: {}   // player name -> points for current round (before validate)
    };

    // Initialize current round
    names.forEach(function(name) { ptibakState.currentRound[name] = 0; });

    document.getElementById('ptibakSetup').style.display = 'none';
    document.getElementById('ptibakGame').style.display = 'block';

    ptibakRenderPlayers();
    ptibakUpdateInfo();
}

function ptibakRenderPlayers() {
    var container = document.getElementById('ptibakPlayers');
    var html = '';

    ptibakState.players.forEach(function(player) {
        var currentPts = ptibakState.currentRound[player.name] || 0;
        var isQualified = player.points >= ptibakState.qualifPoints;

        var borderColor = isQualified ? '#4a7c28' : 'var(--border-color)';
        var bgColor = isQualified ? 'rgba(74,124,40,0.1)' : 'var(--bg-primary)';

        // Button color based on current round selection
        var btnStyle0 = currentPts === 0 ? 'background:#666;color:white' : 'background:var(--bg-secondary);color:var(--text-secondary)';
        var btnStyle1 = currentPts === 1 ? 'background:#2196F3;color:white' : 'background:var(--bg-secondary);color:var(--text-secondary)';
        var btnStyle2 = currentPts === 2 ? 'background:#ff9800;color:white' : 'background:var(--bg-secondary);color:var(--text-secondary)';

        html += '<div style="border:2px solid ' + borderColor + ';border-radius:10px;padding:10px;background:' + bgColor + ';text-align:center">';
        html += '<div style="font-weight:bold;font-size:0.95em;margin-bottom:4px;color:var(--text-primary)">' + player.name + (isQualified ? ' ‚úÖ' : '') + '</div>';
        html += '<div style="display:flex;align-items:center;justify-content:center;gap:6px;margin-bottom:8px">';
        html += '<button onclick="ptibakAdjustPts(\'' + player.name.replace(/'/g, "\\'") + '\', -1)" style="background:#e74c3c;color:white;border:none;border-radius:50%;width:22px;height:22px;cursor:pointer;font-weight:bold;font-size:0.85em;line-height:22px;padding:0">‚àí</button>';
        html += '<span style="font-size:1.3em;font-weight:bold;color:var(--text-accent)">' + player.points + ' pt' + (player.points > 1 ? 's' : '') + '</span>';
        html += '<button onclick="ptibakAdjustPts(\'' + player.name.replace(/'/g, "\\'") + '\', 1)" style="background:#4a7c28;color:white;border:none;border-radius:50%;width:22px;height:22px;cursor:pointer;font-weight:bold;font-size:0.85em;line-height:22px;padding:0">+</button>';
        html += '</div>';
        html += '<div style="display:flex;gap:4px;justify-content:center">';
        html += '<button onclick="ptibakSetRoundPts(\'' + player.name.replace(/'/g, "\\'") + '\', 0)" style="' + btnStyle0 + ';border:none;border-radius:6px;padding:4px 10px;cursor:pointer;font-weight:bold;font-size:0.85em">0</button>';
        html += '<button onclick="ptibakSetRoundPts(\'' + player.name.replace(/'/g, "\\'") + '\', 1)" style="' + btnStyle1 + ';border:none;border-radius:6px;padding:4px 10px;cursor:pointer;font-weight:bold;font-size:0.85em">1</button>';
        html += '<button onclick="ptibakSetRoundPts(\'' + player.name.replace(/'/g, "\\'") + '\', 2)" style="' + btnStyle2 + ';border:none;border-radius:6px;padding:4px 10px;cursor:pointer;font-weight:bold;font-size:0.85em">2</button>';
        html += '</div>';
        html += '</div>';
    });

    container.innerHTML = html;
}

function ptibakAdjustPts(playerName, delta) {
    if (!ptibakState) return;
    var player = ptibakState.players.find(function(p) { return p.name === playerName; });
    if (!player) return;
    player.points += delta;
    if (player.points < 0) player.points = 0;
    ptibakRenderPlayers();
    ptibakUpdateInfo();
}

function ptibakSetRoundPts(playerName, pts) {
    if (!ptibakState) return;
    var player = ptibakState.players.find(function(p) { return p.name === playerName; });
    if (!player) return;

    // If player is already qualified, don't allow points
    if (player.points >= ptibakState.qualifPoints) return;

    ptibakState.currentRound[playerName] = pts;
    ptibakRenderPlayers();
}

function ptibakUpdateInfo() {
    var info = document.getElementById('ptibakInfo');
    var qualified = ptibakState.players.filter(function(p) { return p.points >= ptibakState.qualifPoints; });
    var remaining = ptibakState.qualifSlots - qualified.length;

    var text = 'Tour n¬∞' + (ptibakState.roundNumber + 1);
    text += ' | Qualification : ' + ptibakState.qualifPoints + ' pts';
    text += ' | Qualifi√©s : ' + qualified.length + '/' + ptibakState.qualifSlots;
    if (remaining > 0) {
        text += ' | Places restantes : ' + remaining;
    } else {
        text += ' | ‚úÖ Toutes les places sont prises !';
    }
    info.textContent = text;
}

function ptibakValidateRound() {
    if (!ptibakState) return;

    // Check if any points were given this round
    var anyPoints = false;
    for (var name in ptibakState.currentRound) {
        if (ptibakState.currentRound[name] > 0) { anyPoints = true; break; }
    }
    if (!anyPoints) {
        alert('Aucun point n\'a √©t√© attribu√© ce tour !');
        return;
    }

    // Save round history
    var roundData = {};
    for (var name in ptibakState.currentRound) {
        roundData[name] = ptibakState.currentRound[name];
    }
    ptibakState.history.push(roundData);

    // Apply points
    ptibakState.players.forEach(function(player) {
        // Only add points if not already qualified
        if (player.points < ptibakState.qualifPoints) {
            player.points += (ptibakState.currentRound[player.name] || 0);
        }
    });

    ptibakState.roundNumber++;

    // Reset current round
    ptibakState.players.forEach(function(player) {
        ptibakState.currentRound[player.name] = 0;
    });

    // Show undo button
    document.getElementById('ptibakUndoBtn').style.display = 'inline-block';

    // Generate Discord message
    ptibakGenerateMessage();

    ptibakRenderPlayers();
    ptibakUpdateInfo();
}

function ptibakGenerateMessage() {
    var state = ptibakState;
    var qualifPts = state.qualifPoints;
    var qualifSlots = state.qualifSlots;

    // Sort players by points descending
    var sorted = state.players.slice().sort(function(a, b) {
        if (b.points !== a.points) return b.points - a.points;
        return a.name.localeCompare(b.name);
    });

    var qualified = sorted.filter(function(p) { return p.points >= qualifPts; });
    var remaining = qualifSlots - qualified.length;

    var lines = [];

    // Always show qualification points line
    lines.push('*Points n√©cessaires pour se qualifier : ' + qualifPts + '*');

    // Show qualified players line only if at least one is qualified
    if (qualified.length > 0) {
        lines.push('*Joueurs d√©j√† qualifi√©s : ' + qualified.map(function(p) { return p.name; }).join(', ') + ' (' + qualified.length + ' qualifi√©' + (qualified.length > 1 ? 's' : '') + '/' + qualifSlots + ')*');
    }
    lines.push('');

    // Filter out qualified players from ranking
    var nonQualified = sorted.filter(function(p) { return p.points < qualifPts; });

    // Group non-qualified players by points
    var groups = [];
    var currentGroup = null;
    nonQualified.forEach(function(player) {
        if (!currentGroup || currentGroup.points !== player.points) {
            currentGroup = { points: player.points, players: [] };
            groups.push(currentGroup);
        }
        currentGroup.players.push(player);
    });

    // Build ranking lines
    groups.forEach(function(group) {
        var names = group.players.map(function(p) { return p.name; });
        var ptLabel = group.points > 1 ? ' pts' : ' pt';
        lines.push(names.join(', ') + ' -> ' + group.points + ptLabel);
    });

    // Remaining slots line
    if (remaining > 0) {
        lines.push('');
        lines.push('Plus que ' + remaining + ' place' + (remaining > 1 ? 's' : '') + ' pour se qualifier');
    } else {
        lines.push('');
        lines.push('‚úÖ Toutes les places qualificatives sont prises !');
    }

    var message = lines.join('\n');

    document.getElementById('ptibakMessage').textContent = message;
    document.getElementById('ptibakOutput').style.display = 'block';
}

function ptibakUndoRound() {
    if (!ptibakState || ptibakState.history.length === 0) return;

    var lastRound = ptibakState.history.pop();

    // Subtract points
    ptibakState.players.forEach(function(player) {
        player.points -= (lastRound[player.name] || 0);
        if (player.points < 0) player.points = 0;
    });

    ptibakState.roundNumber--;

    // Reset current round
    ptibakState.players.forEach(function(player) {
        ptibakState.currentRound[player.name] = 0;
    });

    // Hide undo if no more history
    if (ptibakState.history.length === 0) {
        document.getElementById('ptibakUndoBtn').style.display = 'none';
    }

    // Hide message output
    document.getElementById('ptibakOutput').style.display = 'none';

    ptibakRenderPlayers();
    ptibakUpdateInfo();
}

function ptibakReset() {
    if (!confirm('R√©initialiser la poule Ptibak ?')) return;

    ptibakState = null;
    document.getElementById('ptibakSetup').style.display = 'block';
    document.getElementById('ptibakGame').style.display = 'none';
    document.getElementById('ptibakOutput').style.display = 'none';
    document.getElementById('ptibakUndoBtn').style.display = 'none';
}

function ptibakCopyMessage() {
    var msg = document.getElementById('ptibakMessage').textContent;
    navigator.clipboard.writeText(msg).then(function() {
        var el = document.getElementById('ptibakMessage');
        var origBorder = el.style.borderColor;
        el.style.borderColor = '#4a7c28';
        el.style.boxShadow = '0 0 10px rgba(74,124,40,0.5)';
        setTimeout(function() {
            el.style.borderColor = origBorder;
            el.style.boxShadow = 'none';
        }, 1000);
        showMsg('Message copi√© !', 'success');
    }).catch(function() {
        // Fallback
        var ta = document.createElement('textarea');
        ta.value = msg;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showMsg('Message copi√© !', 'success');
    });
}

// ==================== INIT ====================
(async function() {
    // Dark mode
    const dm = localStorage.getItem('gammopDarkMode');
    if (dm === 'true') document.body.classList.add('dark-mode');

    // Set today's date
    const dateInput = document.getElementById('seasonDate');
    if (dateInput) dateInput.value = new Date().toISOString().split('T')[0];

    const isAuthCallback = document.documentElement.getAttribute('data-auth-callback') === 'true';

    // Safety fallback: if nothing has resolved after 3s, force login screen
    setTimeout(() => {
        if (!authResolved) {
            console.warn('[AUTH] fallback timeout ‚Äî forcing login screen');
            showLogin();
        }
    }, 3000);

    if (isAuthCallback) {
        // Auth callback in progress (Magic Link hash OR OAuth PKCE ?code=)
        // Show loading immediately, let SDK + onAuthStateChange handle the rest
        showLoadingScreen();
        console.log('[AUTH] auth callback detected ‚Äî showing loader, waiting for SDK...');

        // If hash contains tokens, consume them explicitly
        await handleHashCallback();

        // For PKCE (?code=), the SDK exchanges the code automatically.
        // onAuthStateChange will fire SIGNED_IN when done ‚Üí showAdmin().
        // checkSession as secondary check after a short delay for PKCE to complete.
        await new Promise(r => setTimeout(r, 500));
        if (!authResolved) {
            console.log('[AUTH] post-callback ‚Äî checking session...');
            await checkSession();
        }
    } else {
        // Normal load (no callback) ‚Äî just check existing session
        await checkSession();
    }
})();
</script>
</body>
</html>
